TEAM VOTE: do we call it a "lazy susan" or a "turret" in the code? Very important

How to set the default subsystemMode before the subsystem is initialized?
	Is subsystemMode in Drive the same one in Subsystem.java or are they separate?
Test driving the robot and using a subsystem at the same time

Parser:
	Update the tokens for the 2019 season. Ex: Replace "intake" with "hatch" and "cargo"
	Parse through the auto file line by line
		Read the whole file in as a single string
		Read the first line and if its a command you run it. Ex: if it says drive 10, then run a drive task to move 10 inches
		If its a serial/bundle, skip through the string until you find a "}." Once the number of "}" equals the number of "{," use 
		substrings to recurse and run those commands either in serial or bundle
		Look at whiteboard pic for more information

Write auto code:
	We'll write individual auto files once the parser is complete

Turret Lock:
	Use the limelight camera to make the turret (lazy susan) lock onto the vision target regardless of the robot orientation.
	Even if the front of the robot is 30 degrees off from facing forward, we can use limelight to make sure the lazy susan (turret) is 
	still facing forward relative to the vision tape. If the angle offset starts going up, we move the turret. This is a control loop

SmartDashboard integration:
	Set test values that are changed often (coefficients/constants, motor powers, etc) through the SmartDashboard. The end goal is that 
	the code is constantly feeding these values in from the SmartDashboard, so even if the robot is constantly enabled we can switch 
	the Hatch arm speed from 0.25 to 0.30 and it would update in real time. There would also be a toggle on this feature, so that we 
	don't accidentally change values right before or during a match.

PID Loops:
	Write the loops for the hatch, cargo, turret lock (maybe), etc:
		This will be possible once we have finalized designs for these subsystems. We can hold off on this for now
	Tune the loops:
		We can tune them slightly when initially testing, but our main tuning will occur when the robot is finished and we have testing 
		time

Logger:
	Do we want to use the logger this year? What improvements can we make to it?
	Once those questions are answered and implemented, begin adding Logger calls throughout the code

Path code:
	It's a mess. Just do your best

Look at all the TODO's in the project and start doing them:
	We never get to this. Maybe this year it'll be different...

Config file:
	If desired, you can make a .config file of some sort allowing for quick changes to control layouts.
	The code would read the config files and look for the specified buttons/axis assigned to a specified action, then execute that action
		Ex: A variable holds the button ID which will be used for the hatch arm. It gets the ID from the config file upon robotInit, and if 
		the button with that ID is pressed, it runs the hatch dropoff.
Write the code for the ShuffleBoard:
	Create the file and set up the ShuffleBoard so that we can pick different auto files to run, much like last year
	Allow the user to enter values for different constants/motor speeds (like Path constants or the arm motor speed for example)
	
Good Vision:
	-Auto Align:
		-Working with Limelight
			-Account for "wrong" pairs. These are pairs of tape made from two ends of different pairs. They do not line up in front of 
			a target; they line up between targets. If we don't account for these pairs in our detection, we simply account for them in 
			the count of how many pairs we see before some action
	-Color Sensor
		-Wiring them on the very edges of the robot
		-Writing the code to utilize them alongside Limelight and encoders

Auto:
	-Write new auto code:
		-Make new path files
		-Take a ball or hatch to any spot on the bay
			-Dont drop the hatch until the driver confirms the position
			-New naming convention
		-5 Start Positions:
			Level 2: L   R
			Level 1: L M R
	-Shuffleboard integration
	-Use vision code in auto
	-Displaying camera to the Driver Station
	-Improve scripting language
		-Align task?
		-The compiler could be much more sophisticated and robust; low priority though
	
Misc:
	-Create a Programming Phamplet of all the cool stuff we do this year
	-Create an Auto Modes Booklet for all of our auto modes (if we have a lot)